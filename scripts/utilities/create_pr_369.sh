#!/usr/bin/env bash
# Helper script to reliably create the PR for Issue 369 (auto-generate types codegen)
# Safe to re-run: if the PR already exists it will show its URL.
# Usage:
#   ./create_pr_369.sh            # Creates (or shows) the PR
#   DRY_RUN=1 ./create_pr_369.sh  # Prints the gh command without executing
#   EXTRA_LABELS="contracts,codegen" ./create_pr_369.sh

set -euo pipefail

ISSUE_NUM=369
DEFAULT_TITLE="Issue 369: Auto-generate contract types codegen"
DEFAULT_BRANCH="auto-generate-types-codegen-369"
BASE_BRANCH="main"
BODY_FILE="pr_body_369.md"

# Detect current branch (allow running from another branch if desired)
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
HEAD_BRANCH="${CURRENT_BRANCH}"  # Use current branch by default

if [[ "${CURRENT_BRANCH}" != "${DEFAULT_BRANCH}" ]]; then
  echo "âš ï¸  You are on branch '${CURRENT_BRANCH}', expected '${DEFAULT_BRANCH}'."
  echo "    Proceeding anyway (HEAD branch will be '${CURRENT_BRANCH}')."
fi

# Ensure working tree is clean
if [[ -n "$(git status --porcelain)" ]]; then
  echo "âŒ Working tree not clean. Commit or stash changes first." >&2
  exit 1
fi

# Ensure branch is pushed
if ! git ls-remote --exit-code --heads origin "${HEAD_BRANCH}" >/dev/null 2>&1; then
  echo "ðŸŒ Pushing branch '${HEAD_BRANCH}' to origin..."
  git push -u origin "${HEAD_BRANCH}"
fi

# Prepare PR body file if missing
if [[ ! -f "${BODY_FILE}" ]]; then
  echo "ðŸ“ Generating ${BODY_FILE}..."
  VERIFY_OUTPUT_FILE="/tmp/verify_369_output.txt"
  if [[ -x scripts/verify_issue_369_dod.py ]]; then
    echo "   Running DoD verifier to embed output..."
    if python3 scripts/verify_issue_369_dod.py >"${VERIFY_OUTPUT_FILE}" 2>&1; then
      VERIFY_SUMMARY=$(grep -E "(All DoD criteria satisfied|Issue 369 DoD Status)" "${VERIFY_OUTPUT_FILE}" || true)
    else
      VERIFY_SUMMARY="Verification script reported issues (see below)"
    fi
  else
    VERIFY_SUMMARY="Verification script not executable or missing"
  fi

  cat > "${BODY_FILE}" <<'EOF'
# Issue 369: Auto-generate contract types codegen

Closes #369

## Summary
Implements automated generation of strongly-typed Pydantic models from both Avro and JSON Schema contracts to eliminate drift, enforce consistency, and enable safer refactors.

## Key Features
- Unified `scripts/contracts/codegen.py` handling Avro + JSON Schema
- Deterministic module + class naming (hyphen -> underscore sanitation)
- Generated package under `services/generated/` with import-friendly structure
- CI-ready build script `build_types.sh` including anti-drift detection
- Schema coverage verification + DoD verification script `scripts/verify_issue_369_dod.py`
- Documentation with usage examples in `services/generated/README.md`

## Implementation Highlights
- Normalizes schema identifiers to valid Python modules (`ask-request-v1` -> `ask_request_v1_models.py`)
- Generates `__init__.py` aggregators for ergonomic imports
- Captures required field metadata and optionality using Pydantic `Field`
- Validates syntax of generated code during build (fast failure)
- Extensible architecture: separate generator classes (`AvroTypeGenerator`, `JsonSchemaTypeGenerator`)

## Definition of Done Verification
Below is an excerpt of the verification output (full run executed locally):

```
EOF
  # Append verifier output (truncated to 120 lines)
  if [[ -f "${VERIFY_OUTPUT_FILE}" ]]; then
    head -n 120 "${VERIFY_OUTPUT_FILE}" >> "${BODY_FILE}"
  else
    echo "(verification output unavailable)" >> "${BODY_FILE}"
  fi
  cat >> "${BODY_FILE}" <<'EOF'
```

## Follow-ups / Future Enhancements
- Integrate into CI pipeline (pre-merge enforcement)
- Add mypy plugin or stub generation for tighter typing
- Optionally emit TypeScript types for frontend consumption

## Risks & Mitigations
| Risk | Mitigation |
|------|------------|
| Drift reintroduced by manual edits | Build script enforces regeneration + detection |
| Naming collisions | Deterministic sanitized naming + suffix `_models` |
| Large schema growth | Modular per-schema files + lazy imports |

## Checklist
- [x] Code generation script
- [x] Generated models compile
- [x] DoD verifier passes
- [x] Docs updated
- [x] Branch pushed

---
Automated PR body generated by `create_pr_369.sh`.
EOF
fi

# Determine labels
EXTRA_LABELS_CLEAN="${EXTRA_LABELS:-}"  # comma separated allowed
LABEL_FLAGS=()
if [[ -n "${EXTRA_LABELS_CLEAN}" ]]; then
  IFS=',' read -r -a _arr <<<"${EXTRA_LABELS_CLEAN}"
  for l in "${_arr[@]}"; do
    LABEL_FLAGS+=(--label "$l")
  done
fi
# Provide a sane default set
if [[ ${#LABEL_FLAGS[@]} -eq 0 ]]; then
  LABEL_FLAGS=(--label enhancement --label contracts --label codegen)
fi

# Try to detect milestone (optional); ignore errors
MILESTONE_FLAG=()
if gh milestone list >/dev/null 2>&1; then
  M_ID=$(gh milestone list --limit 20 | grep -i "contract" | head -n1 | awk '{print $NF}' | sed 's/#//g' || true)
  if [[ -n "${M_ID}" ]]; then
    MILESTONE_FLAG=(--milestone "${M_ID}")
  fi
fi

# If PR already exists, show it
if gh pr view "${HEAD_BRANCH}" >/dev/null 2>&1; then
  echo "âœ… PR already exists for branch '${HEAD_BRANCH}':"
  gh pr view "${HEAD_BRANCH}" --json url,title,number --template '{{.number}} {{.title}} -> {{.url}}\n'
  exit 0
fi

CMD=(gh pr create \
  --title "${DEFAULT_TITLE}" \
  --body-file "${BODY_FILE}" \
  --base "${BASE_BRANCH}" \
  --head "${HEAD_BRANCH}" \
  "${LABEL_FLAGS[@]}" \
  "${MILESTONE_FLAG[@]}"
)

if [[ "${DRY_RUN:-0}" == "1" ]]; then
  echo "ðŸ”Ž DRY RUN: Would execute:" >&2
  printf ' %q' "${CMD[@]}"; echo
  exit 0
fi

# Execute PR creation
if ! command -v gh >/dev/null 2>&1; then
  echo "âŒ GitHub CLI (gh) not installed. Install from https://cli.github.com/" >&2
  exit 1
fi

if ! gh auth status >/dev/null 2>&1; then
  echo "ðŸ” Not authenticated to GitHub. Run: gh auth login" >&2
  exit 1
fi

echo "ðŸš€ Creating PR..."
"${CMD[@]}"

echo "âœ… PR created successfully."
